# 时间复杂度分析

<code>C++</code>一般$1s$能计算$10^7$~$10^8$次，在这种情况下，<code>C++</code>代码中的操作次数控制在 $10^7$为最佳。

因此，在不同数据范围下，代码的时间复杂度和算法的选择技巧如下：

## n<=30，指数级别

| dfs+剪枝 | 状态压缩dp |
| -------- | ---------- |

## n<=100,$O(n^3)$

| floyd | dp   |
| ----- | ---- |

## n<=1000,$O(n^2)$,$O(n^2logn)$

| dp               | 朴素版Dijkstra |
| ---------------- | -------------- |
| **二分**         | **朴素版Prim** |
| **Bellman-Ford** |                |

## n<=10000,$O(n\sqrt{n})$

| 块链表   | 分块 |
| -------- | ---- |
| **莫队** |      |

## n<=$10^5$,$O(nlogn)$

| heap               | 线段树          |
| ------------------ | --------------- |
| **树状数组**       | **set**/**map** |
| **各种排序算法**   | **拓扑排序**    |
| **堆优化Dijkstra** | **堆优化Prim**  |
| **SPFA**           | **求凸包**      |
| **求半平面交**     | **二分**        |

## n<=$10^6$,$O(n)$

| Hash         | 双指针扫描 |
| ------------ | ---------- |
| **并查集**   | **KMP**    |
| **AC自动机** |            |

## n<=$10^6$,常数较小的$O(nlogn)$

| 排序     | 树状数组     |
| -------- | ------------ |
| **heap** | **Dijkstra** |
| **SPFA** |              |

## n<=$10^7$,$O(n)$

| 双指针扫描   | KMP            |
| ------------ | -------------- |
| **AC自动机** | **线性筛素数** |

## n<=$10^9$,$O(\sqrt{n})$

| 判断质数 |
| -------- |

## n<=$10^{18}$,$O(logn)$

| 最大公约数 | 快速幂 |
| ---------- | ------ |

## n<=$10^{1000}$,$O((logn)^2)$

| 高精度加减乘除 |
| -------------- |

## n<=$10^{100000}$,$O(\log n\times \log\log n)$

| 高精度加减 | FFT/NTT |
| ---------- | ------- |

## Tips

$\log_2 10^n =3n$

64MB至多开1600万个<code>int</code>

[由数据范围反推算法复杂度以及算法内容 - AcWing](https://www.acwing.com/blog/content/32/)